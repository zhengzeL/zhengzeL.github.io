[{"content":"简介 官网：https://www.npmjs.com/\nNPM是Node.js包管理工具，相当于前端的Maven\n1 2 # 在命令行输入npm -v 可查看当前npm版本 npm -v 快速开始 在项目目录下执行npm init初始化项目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 最终生成package.json文件 { \u0026#34;name\u0026#34;: \u0026#34;npm\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;node project\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [ \u0026#34;node\u0026#34; ], \u0026#34;author\u0026#34;: \u0026#34;satan\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 安装模块 npm install 模块名 或 npm i 模块名\n","date":"2023-01-29T00:00:00Z","image":"https://zhengzel.github.io/p/npm%E5%85%A5%E9%97%A8/background_huffb44be3046d49fdcba133f1fa4bac40_124267_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/npm%E5%85%A5%E9%97%A8/","title":"Npm入门"},{"content":"概念 ESMAScript是标准规范，JavaScript是它的实现\n发展流程 let和const的定义 变量和常量的严格区分\n1 2 3 4 5 6 7 8 9 10 11 // 传统定义变量和常量的方式 统一使用var var name = \u0026#34;zzl\u0026#34;; var link = \u0026#34;https://www.kuangstudy.com\u0026#34;; var PI = Math.PI; // ES6定义的方式 -- 变量 let name = \u0026#34;学相伴\u0026#34;; let link = \u0026#34;https://www.kuangstudy.com\u0026#34;; // 定义常量 const PI = Math.PI; let和const解决了var的变量穿透问题和常量修改问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // let和const解决 // 1. var的变量穿透的问题 // 2. 常量修改的问题 for (var i = 0; i \u0026lt; 5; i++) { console.log(i); } //这里就造成了变量穿透问题 console.log(i); //解决，将var改成let for (let i = 0; i \u0026lt; 5; i++) { console.log(i); } 1 2 3 4 5 6 7 8 9 // var定义常量可以修改 var PI = Math.PI; PI = 100; console.log(PI); // 改用const，无法修改 const PI = Math.PI; PI = 100; console.log(PI); 模板字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 // 字符串会牵扯到动态部分 var person = { name: \u0026#34;zzl\u0026#34;, address: \u0026#34;广东\u0026#34;, }; //传统方式 let info = person.name + \u0026#34;在\u0026#34; + person.address; console.log(info); // ES6 let message = `${person.name}在${person.address}`; console.log(message); 函数默认参数 添加默认参数在未传对应值的时候，也不会出现错误\n1 2 3 4 5 6 7 // 函数默认参数 function sum(a = 50, b = 50) { return a + b; } let result = sum(100, 100); console.log(result); 箭头函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 箭头函数 - 重点 var sum = function (a, b) { return a + b; }; // 改进1 sum = (a, b) =\u0026gt; { return a + b; }; // 改进2 sum = (a, b) =\u0026gt; a + b; // 一个参数 var newarr = arr.map(function(obj){ return obj * 2; }); // 改进 newarr = arr.map(obj=\u0026gt;obj*2); console.log(newarr); 注意：逻辑代码仅有return可以省去，若不是，则不能省去，参数仅有一个时，括号才可省略\n对象初始化简写 核心：是指如果一个对象的key和value的名字一样的情况下可以定义成一个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var info = { title: \u0026#34;广东学相伴\u0026#34;, link: \u0026#34;https://www.kuangstudy.com\u0026#34;, go: function () { console.log(\u0026#34;我上学\u0026#34;); }, }; // ES6简写 // 因为对象是key:value存在 // 1: 如果key和变量的名字一致，可以只定义一次即可 // 2：如果value是一个函数，可以把\u0026#39;:function\u0026#39;去掉，只剩下()即可 let title = \u0026#34;广东学相伴\u0026#34;; let link = \u0026#34;https://www.kuangstudy.com\u0026#34;; let message = { title, link, go() { console.log(\u0026#34;我上学\u0026#34;); }, }; 对象解构 核心：ES6提供一些快捷获取对象属性和行为方式的方法\n1 2 3 4 5 6 7 8 9 10 11 12 let message = { title, link, go() { console.log(\u0026#34;我上学\u0026#34;); }, }; //ES6对象结构 - 其实就是快速获取属性和方法的一种形式 var { title, link } = message; console.log(title); console.log(link); 传播操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 对象传播操作符 ... var info = { name: \u0026#34;广东学相伴\u0026#34;, address: \u0026#34;广东\u0026#34;, link: \u0026#34;https://www.kuangstudy.com\u0026#34;, go: function () { console.log(\u0026#34;我上学\u0026#34;); }, }; // 解构出来 // ...person会取出除了name和address的其他属性 var { name, address, ...person } = info; console.log(name); console.log(address); console.log(person) 数组map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 要对arr数组每个元素*2 let arr = [1, 2, 3, 4, 5, 6, 7]; // 传统的方式 let newarr = []; for (let i = 0; i \u0026lt; arr.length; i++) { newarr.push(arr[i] * 2); } console.log(newarr); // map -- 自带的循环，并且会把处理的值回填对应的位置 var newarr2 = arr.map(function (ele) { return ele * 2; }); console.log(newarr2); var users = [ { age: 10, name: \u0026#34;小学\u0026#34; }, { age: 12, name: \u0026#34;小信\u0026#34; }, { age: 15, name: \u0026#34;小胖\u0026#34; }, ]; var newusers = users.map((ele) =\u0026gt; { ele.age += 1; return ele; }); console.log(newusers); 数组reduce 接受一个函数和一个初始值，该函数接收两个参数，一个是上次处理的结果，另一个是下一个要处理的结果\n1 2 3 4 5 var arr = [1, 2, 3, 4]; var result = arr.reduce(function (a, b) { return a + b; }); console.log(\u0026#34;Result=\u0026#34;, result); ","date":"2023-01-24T00:00:00Z","image":"https://zhengzel.github.io/p/es6%E5%85%A5%E9%97%A8/background_huf753159c48d2760b6e1fbd6aa083bd5f_185787_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/es6%E5%85%A5%E9%97%A8/","title":"ES6入门"},{"content":"介绍 Node 是 一个让JavaScript运行在服务端的开发平台，它让JavaScript 成为与PHP，Python,Perl,Ruby等服务端语言平起平坐的脚步语言，实质是对chrome v8引擎进行了封装\nNode.js就是运行在服务器端的JavaScript\n安装 官网：https://nodejs.org/zh-cn/\n下载页：https://nodejs.org/zh-cn/download\n选择合适的下载即可\n下载完成后进入cmd输入node -v，若输出版本号则安装成功！\n编译原理 实现请求响应 1 创建server-app.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 导入模块是require 就类似于import java.io const http = require(\u0026#34;http\u0026#34;); // 1. 创建一个httpServer服务 http .createServer(function (require, response) { // 浏览器怎么认识hello server! // 以text/html去解析 hello server 这段数据 response.writeHead(200, { \u0026#34;Content-type\u0026#34;: \u0026#34;text/html\u0026#34; }); // 给浏览器输出内容 response.end(\u0026#34;\u0026lt;strong\u0026gt;hello server!!!\u0026lt;/strong\u0026gt;\u0026#34;); }) .listen(8888); // 2. 监听--端口8888 console.log(\u0026#34;你启动的服务是：http://localhost:8888已启动成功！\u0026#34;); // 3. 启动运行服务 node Httpserver.js 2 在浏览器访问http://localhost:8888，结果如下\n操作Mysql数据库 参考：https://www.npmjs.com/package/mysql\n安装mysql依赖 1 npm install mysql 创建db.js文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1. 导入mysql依赖包 var mysql = require(\u0026#34;mysql\u0026#34;); // 2. 创建一个mysql的Connection对象,并配置数据连接的信息 var connection = mysql.createConnection({ host: \u0026#34;localhost\u0026#34;, user: \u0026#34;root\u0026#34;, password: \u0026#34;123456\u0026#34;, database: \u0026#34;testdb\u0026#34;, //数据库名 }); // 4. 开辟连接 connection.connect(); // 5. 执行crud connection.query(\u0026#34;select * from user\u0026#34;, (err, result) =\u0026gt; { if (err) throw err; console.log(result); }); // 6. 关闭连接 connection.end(); 在终端执行node+文件名，获得如下结果\n1 2 3 4 5 PS D:\\Files\\前端\\NodeJs\u0026gt; node db.js [ RowDataPacket { id: 1, name: \u0026#39;小明\u0026#39; }, RowDataPacket { id: 2, name: \u0026#39;小红\u0026#39; } ] ","date":"2023-01-21T00:00:00Z","image":"https://zhengzel.github.io/p/nodejs%E5%85%A5%E9%97%A8/background_huc9101f9c44a958fd3fec2e1aeb9cec43_771375_120x120_fill_box_smart1_3.png","permalink":"https://zhengzel.github.io/p/nodejs%E5%85%A5%E9%97%A8/","title":"NodeJs入门"},{"content":"概述 ElasticSearch，简称为es，是一个开源的高扩展的分布式全文检索引擎\n具有以下优点\n本身扩展性很好 能够近乎实时的存储，检索数据 与Solr的差别 es基本是开箱即用，非常简单，Solr安装则稍微复杂一点 Solr利用Zookeeper进行分布式管理，而ElasticSearch自身带有分布式协调管理功能 Solr支持更多格式的数据，比如json,xml，csv，而ElasticSearch仅支持json文件 Solr官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多由第三方插件提供 Solr查询快，但更新索引时慢（即插入删除慢）,用于电商等查询多的应用 Elasticsearch实时性查询快，用于facebook新浪等搜索 Solr比较成熟，有着活跃的社区，而Elasticsearch开发维护者 较少，更新较快，学习成本较高 Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用，推荐使用ES\n安装 1 2 3 4 5 # 环境要求 JDk1.8，最低要求，保证环境是正常的 ElasticSearch客户端，界面工具 # Java开发 ElasticSearch的版本和jar包版本对应 下载\n官网：https://www.elastic.co/cn/\n下载页：https://www.elastic.co/cn/downloads/elasticsearch\nwindows下解压即可使用\n熟悉目录\n1 2 3 4 5 6 7 8 9 |____ bin # 启动文件 |____ config # 配置文件 |____ log4j2 # 日志配置 |____ jvm.options # java虚拟机相关的配置 |____ elasticsearch.yml # elasticsearch的配置文件，默认9200端口 |____ lib # 相关jar包 |____ logs # 日志 |____ modules # 功能模块 |____ plugins # 插件 ik分词器 启动Es\n进入bin目录下启动elasticsearch.bat,启动完成后访问http://127.0.0.1:9200，出现如下界面则启动成功\n如果出现无法访问的情况，可以进入elasticsearch.yml修改配置，将下面两个选项改为false\n安装可视化界面es head的插件\n","date":"2023-01-19T00:00:00Z","image":"https://zhengzel.github.io/p/elasticsearch%E5%85%A5%E9%97%A8/background_hua80d3c6f1bbf1e0f1d63b8e880a4887b_241267_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/elasticsearch%E5%85%A5%E9%97%A8/","title":"ElasticSearch入门"},{"content":"","date":"2023-01-12T00:00:00Z","image":"https://zhengzel.github.io/p/springcloud%E5%85%A5%E9%97%A8/background_hufd682545f59d0350841f4e69d2319eef_543770_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/springcloud%E5%85%A5%E9%97%A8/","title":"SpringCloud入门"},{"content":"安装Docker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 1. 卸载旧的版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2. 需要的安装包 yum install -y yum-utils # 3. 设置镜像的仓库 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 4. 更新yum软件包索引 yum makecache fast # 5. 安装docker相关的依赖 yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin # 6. 启动docker systemctl start docker # 7. 使用docker version查看是否安装成功 # 8. Hello world docker run hello-world # 9. 查看一下下载的这个hello-world镜像 docker images 卸载Docker 1 2 3 4 5 6 # 1. 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin # 2. 删除资源 rm -rf /var/lib/docker # docker的默认工作路径 rm -rf /var/lib/containerd 阿里云镜像加速 登录阿里云找到容器服务 找到镜像加速地址 Docker为什么比vm快 Docker有着比虚拟机更少的抽象层\ndocker利用的是宿主机的内核，vm需要的是Guest OS\nRun流程 Docker \u0026ndash; 帮助命令 1 2 3 docker version\t# 显示docker的版本信息 docker info # 显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help # 万能命令 帮助命令 docker命令文档\nDocker \u0026ndash; 镜像命令 查看镜像 docker images #查看所有本地的主机上的镜像\n1 2 3 4 5 6 7 8 9 10 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest feb5d9fea6a5 15 months ago 13.3kB # 解释 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像的id CREATED 镜像的创建时间 SIZE 镜像的大小 搜索镜像 docker search 镜像名称\n1 2 3 4 5 6 7 [root@docker ~]# docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used 13681 [OK] mariadb MariaDB Server is a high 5225 [OK] # 可选项 过滤条件 --filter=STARS=3000 # 搜索出来的镜像的STARS大于3000的 下载镜像 docker pull 镜像名称\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@docker ~]# docker pull mysql[:tag] 可选项 tag 指定版本 Using default tag: latest latest: Pulling from library/mysql 72a69066d2fe: Pull complete # 分层下载，docker镜像的核心 93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 688ba7d5c01a: Pull complete 00e060b6d11d: Pull complete 1c04857f594f: Pull complete 4d7cfa90e6ea: Pull complete e0431212d27d: Pull complete Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest 删除镜像 docker rmi 镜像ID #删除指定镜像\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [root@docker ~]# docker rmi -f c20987f18b13 Untagged: mysql:5.7 Untagged: mysql@sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94 Deleted: sha256:c20987f18b130f9d144c9828df630417e2a9523148930dc3963e9d0dab302a76 Deleted: sha256:6567396b065ee734fb2dbb80c8923324a778426dfd01969f091f1ab2d52c7989 Deleted: sha256:0910f12649d514b471f1583a16f672ab67e3d29d9833a15dc2df50dd5536e40f Deleted: sha256:6682af2fb40555c448b84711c7302d0f86fc716bbe9c7dc7dbd739ef9d757150 Deleted: sha256:5c062c3ac20f576d24454e74781511a5f96739f289edaadf2de934d06e910b92 # 删除多个镜像 docker rmi -f 镜像id 镜像id 镜像id 镜像id # 删除所有镜像 docker rmi -f $(docker images -aq) Docker \u0026ndash; 容器命令 说明： 有了镜像才可以创建容器，所以先下载一个centos镜像来测试学习\n1 docker pull centos 创建容器 docker run [可选参数] image 启动容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 新建容器并启动 docker run [可选参数] image # 可选参数说明 --name=\u0026#39;Name\u0026#39; 容器名字 tomcat01/tomcat02 用来区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 -p -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 -P 随机指定端口 # 测试，启动并进入容器 [root@docker ~]# docker run -it centos /bin/bash [root@2913f3a8c3b9 /]# ls 查看容器内的centos bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr 查看容器 docker ps # 查看当前正在运行中的容器\n1 2 3 4 5 6 7 [root@docker /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # 可选参数说明 -a # 查看所有的容器，包括未运行的容器 -n=? # 显示最近创建的容器，？为显示个数 -q # 只显示容器的编号 退出容器 1 2 3 4 5 # 直接停止容器并退出 [root@2913f3a8c3b9 /]# exit # 容器不停止退出 Ctrl + P + Q 删除容器 docker rm 容器ID # 删除指定容器，不能删除正在运行的容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [root@docker /]# docker ps -aq 8f6cded1de29 2913f3a8c3b9 1e9519071c11 38e22de26669 [root@docker /]# docker rm 8f6cded1de29 8f6cded1de29 [root@docker /]# docker ps -aq 2913f3a8c3b9 1e9519071c11 38e22de26669 # 删除所有容器 docker rm -f $(docker ps -aq) docker ps -a -q|xargs docker rm 启动容器 docker start 容器id\n1 2 3 4 # 补充 docker restart 容器id # 重启容器 docker stop 容器id # 停止当前正在运行的容器 docker kill 容器id # 强制停止当前容器 常用的其他命令 后台启动容器 docker run -d 镜像名\n1 2 3 4 5 6 7 8 [root@docker /]# docker run -d centos eddc149d6e24582c1d8fe356f2d9559215f683ee10108fbeb4e4db435f7a3355 [root@docker /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # 问题 docker ps 发现 centos 停止了 # 常见的坑： docker 容器使用后台运行 就必须有一个前台进程,docker发现没有应用，就会自动停止 查看日志 docker logs\n1 2 3 4 # 显示日志 -tf # 显示日志 --tail number # 要显示的日志条数 [root@docker /]# docker logs -tf --tail 10 容器id 查看容器中进程信息 docker top 容器id\n1 2 3 [root@docker /]# docker top e4a8c1e80579 UID PID PPID C STIME TTY TIME CMD root 2942 2923 0 16:02 pts/0 00:00:00 /bin/bash 查看镜像的元数据 docker inspect 容器id\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [root@d6e2d66837c2 /]# [root@docker /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6e2d66837c2 centos \u0026#34;/bin/bash\u0026#34; 12 seconds ago Up 11 seconds thirsty_rhodes [root@docker /]# docker inspect d6e2d66837c2 [ { \u0026#34;Id\u0026#34;: \u0026#34;d6e2d66837c219ba3250c0f45ed984cdc6dd21c8cd23372f36dac3d65dd2e981\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2023-01-12T08:38:21.597122836Z\u0026#34;, \u0026#34;Path\u0026#34;: \u0026#34;/bin/bash\u0026#34;, \u0026#34;Args\u0026#34;: [], \u0026#34;State\u0026#34;: { \u0026#34;Status\u0026#34;: \u0026#34;running\u0026#34;, \u0026#34;Running\u0026#34;: true, \u0026#34;Paused\u0026#34;: false, \u0026#34;Restarting\u0026#34;: false, \u0026#34;OOMKilled\u0026#34;: false, \u0026#34;Dead\u0026#34;: false, \u0026#34;Pid\u0026#34;: 3243, \u0026#34;ExitCode\u0026#34;: 0, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;StartedAt\u0026#34;: \u0026#34;2023-01-12T08:38:21.896883638Z\u0026#34;, \u0026#34;FinishedAt\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34; }, ] 进入当前正在运行的容器 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置\n1 2 3 4 5 6 7 8 9 10 # 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 # 进入容器方式一 docker exec -it 容器id bashShell # 进入容器方式二 docker attach 容器id # docker exec # 进入容器后开启一个新的终端，可以在里面操作 # docker attach # 进入容器正在执行的终端 从容器内拷贝文件到主机上 docker cp 容器id:容器内路径 目标的主机路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 查看home目录下，此时home目录下只有admin [root@docker ~]# cd /home [root@docker home]# ls admin # 启动docker [root@docker home]# systemctl start docker # 当前的镜像 [root@docker home]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5d0da3dc9764 16 months ago 231MB # 新建一个容器并启动 [root@docker home]# docker run -it centos /bin/bash # 进入docker容器内部 [root@47b3a0402593 /]# [root@docker home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 47b3a0402593 centos \u0026#34;/bin/bash\u0026#34; 48 seconds ago Up 47 seconds dreamy_cerf [root@docker home]# docker attach 47b3a0402593 [root@47b3a0402593 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@47b3a0402593 /]# cd /home [root@47b3a0402593 home]# ls # 在容器的home目录内新建一个文件 [root@47b3a0402593 home]# touch test.java [root@47b3a0402593 home]# ls test.java [root@47b3a0402593 home]# exit exit [root@docker home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@docker home]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 47b3a0402593 centos \u0026#34;/bin/bash\u0026#34; 2 hours ago Exited (0) 32 seconds ago dreamy_cerf # 将文件拷贝到虚拟机上的home目录 [root@docker home]# docker cp 47b3a0402593:/home/test.java /home [root@docker home]# ls admin test.java 部署Nginx 搜索镜像 docker search nginx 或者 在 docker Hub上搜索，可以看到帮助文档\n下载镜像 docker pull nginx\n1 2 3 4 5 6 7 8 9 10 11 12 [root@docker ~]# docker pull nginx Using default tag: latest latest: Pulling from library/nginx a2abf6c4d29d: Pull complete a9edb18cadd1: Pull complete 589b7251471a: Pull complete 186b1aaa4aa6: Pull complete b4df32aa5a72: Pull complete a0bcbecc962e: Pull complete Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31 Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest 运行测试 docker run -d \u0026ndash;name nginx -p 3344:80 nginx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 605c77e624dd 12 months ago 141MB centos latest 5d0da3dc9764 16 months ago 231MB # 参数说明 # -d 后台运行 # --name 给容器命名 # -p 端口暴露 宿主机端口：容器内端口 [root@docker ~]# docker run -d --name nginx -p 3344:80 nginx e25907b771ccef91c5e34472a1865c007eba33606a0acb4d738efad0ca72dc61 [root@docker ~]# curl localhost:3344 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 进入容器 1 2 3 4 5 6 [root@docker ~]# docker exec -it nginx /bin/bash root@e25907b771cc:/# whereis nginx nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx root@e25907b771cc:/# cd /etc/nginx root@e25907b771cc:/etc/nginx# ls conf.d fastcgi_params mime.types modules nginx.conf scgi_params uwsgi_params 部署tomcat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 官方的使用 docker run -it --rm tomcat:9.0 # 我们之前的启动都是后台，停止了容器之后，容器还是可以查到 # docker run -it --rm一般用来测试，用完即删 # 1.下载镜像 # docker pull tomcat:9.0 # 2.启动运行 # docker run -d --name tomcat -p 3355:8080 tomcat:9.0 # 3.测试访问没有问题，但是报404错误，进入容器，一探究竟 # docker exec -it tomcat /bin/bash # 4.发现问题 root@bc6aaf2c5773:/usr/local/tomcat# ll # linux命令缺失 bash: ll: command not found root@bc6aaf2c5773:/usr/local/tomcat# cd webapps/ root@bc6aaf2c5773:/usr/local/tomcat/webapps# ls root@bc6aaf2c5773:/usr/local/tomcat/webapps# # webapps目录下为空 # 5.原因：阿里云镜像，默认是最小的镜像，所有不必要都剔除掉，保证最小可运行环境 # 6.解决方式 webapps目录下的文件可以从webapps.dist文件下拷贝 root@bc6aaf2c5773:/usr/local/tomcat# cp -r webapps.dist/* webapps root@bc6aaf2c5773:/usr/local/tomcat# cd webapps root@bc6aaf2c5773:/usr/local/tomcat/webapps# ls ROOT docs examples host-manager manager # 7.ip+端口访问，发现能正常看到页面了 部署ES+Kibana 1 2 # 启动 Elasticsearch，若没有这个镜像则会下载下来 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; elasticsearch:7.6.2 问题，ES比较占内存,所以一核2G的配置很卡，CPU占用大，所以在测试通过后，尽快关闭，解决这个问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 说明ES安装成功 [root@docker ~]# curl localhost:9200 { \u0026#34;name\u0026#34; : \u0026#34;08145df3cc6e\u0026#34;, \u0026#34;cluster_name\u0026#34; : \u0026#34;docker-cluster\u0026#34;, \u0026#34;cluster_uuid\u0026#34; : \u0026#34;td15eI9XTp-yIObP-XKP4w\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;number\u0026#34; : \u0026#34;7.6.2\u0026#34;, \u0026#34;build_flavor\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;build_type\u0026#34; : \u0026#34;docker\u0026#34;, \u0026#34;build_hash\u0026#34; : \u0026#34;ef48eb35cf30adf4db14086e8aabd07ef6fb113f\u0026#34;, \u0026#34;build_date\u0026#34; : \u0026#34;2020-03-26T06:34:37.794943Z\u0026#34;, \u0026#34;build_snapshot\u0026#34; : false, \u0026#34;lucene_version\u0026#34; : \u0026#34;8.4.0\u0026#34;, \u0026#34;minimum_wire_compatibility_version\u0026#34; : \u0026#34;6.8.0\u0026#34;, \u0026#34;minimum_index_compatibility_version\u0026#34; : \u0026#34;6.0.0-beta1\u0026#34; }, \u0026#34;tagline\u0026#34; : \u0026#34;You Know, for Search\u0026#34; } # 使用docker stats查看CPU的状态，此时占用较大 [root@docker ~]# docker stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS ab215f92c5d1 elasticsearch 173.32% 606.9MiB / 972.3MiB 62.42% 656B / 0B 2.56GB / 73.8MB 19 解决方式 增加内存的限制，修改配置文件 -e 环境配置修改\n1 2 # 参数说明 设定最小是64M，最大是512M docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; -e ES_JAVA_OPTS=\u0026#34;-Xms64m -Xmx512m\u0026#34; elasticsearch:7.6.2 1 2 3 4 # 查看CPU的状态 --- 发现占用率下降很多了 [root@docker ~]# docker stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 1ac5d28a7744 elasticsearch 0.15% 394.7MiB / 972.3MiB 40.59% 1.25kB / 996B 214MB / 1.66MB 43 可视化工具 Portainer Docker 图形化界面管理工具，提供一个后台面板供我们操作\n1 2 3 # 启动Portainer docker run -d -p 8088:9000 --name portainer \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 浏览器访问http://ip+端口，获取如下页面，首次登录，需要创建用户名密码\n下一步，选择本地\n进入面板，即可看到详细信息，例如镜像数量，容器情况等\nDocker镜像详解 镜像是什么 是一种轻量化，可执行的独立软件包 用来打包软件运行环境和基于运行环境开发的软件 包括代码，运行时，库，环境变量和配置文件 所有的应用，直接打包docker镜像，就可以直接运行\nDocker镜像加载原理 UnionFS（联合文件系统）\n是一种分层，轻量级并且高性能的文件系统 一次同时加载多个文件系统，在外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 Docker镜像加载原理\ndocker的镜像实际上由一层一层的文件系统组成，这种层次的文件系统就是UnionFS\nbootfs主要包含bootloader和kernel,bootloader主要是引导加载Kernel,Linux刚启动会加载boofs文件系统，Docker容器的最底层就是bootfs,这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs\nrootfs，在bootfs之上，包含的就是典型Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件，rootfs就是各种不同的操作系统发行版，比如Ubuntu,CentOs等等\n平时我们安装进虚拟机的CentOs通常要几个G，为什么Docker这里的才200M\n1 2 3 [root@docker ~]# docker images centos REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5d0da3dc9764 16 months ago 231MB 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel,自己只需要提供rootfs就可以了。由此可见，对于不同的linux发行版，bootfs基本是一致的，只有rootfs有差别，所以它们可以公用bootfs\n分层理解 分层的镜像\n我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载\n1 2 3 4 5 6 7 8 9 10 11 12 [root@docker ~]# docker pull redis Using default tag: latest latest: Pulling from library/redis a2abf6c4d29d: Already exists c7a4e4382001: Pull complete 4044b9ba67c9: Pull complete c8388a79482f: Pull complete 413c8bb60be2: Pull complete 1abfd3011519: Pull complete Digest: sha256:db485f2e245b5b3329fdc7eff4eb00f913e09d8feb9ca720788059fdc2ed8339 Status: Downloaded newer image for redis:latest docker.io/library/redis:latest 思考！为什么 Docker镜像要采用这种分层的结构呢？\n最大的好处，莫过于是资源共享了，比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享\n使用 docker image inspect redis:latest 查看镜像的分层方式\n1 2 3 4 5 6 7 8 9 10 11 \u0026#34;RootFS\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;layers\u0026#34;, \u0026#34;Layers\u0026#34;: [ \u0026#34;sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f\u0026#34;, \u0026#34;sha256:9b24afeb7c2f21e50a686ead025823cd2c6e9730c013ca77ad5f115c079b57cb\u0026#34;, \u0026#34;sha256:4b8e2801e0f956a4220c32e2c8b0a590e6f9bd2420ec65453685246b82766ea1\u0026#34;, \u0026#34;sha256:529cdb636f61e95ab91a62a51526a84fd7314d6aab0d414040796150b4522372\u0026#34;, \u0026#34;sha256:9975392591f2777d6bf4d9919ad1b2c9afa12f9a9b4d260f45025ec3cc9b18ed\u0026#34;, \u0026#34;sha256:8e5669d8329116b8444b9bbb1663dda568ede12d3dbcce950199b582f6e94952\u0026#34; ] }, 特点\nDocker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！\n这一层就是我们通常说的容器层，容器之下都叫镜像层！\ncommit镜像 1 2 docker commit # 提交容器成为一个新的副本 docker commit -m=\u0026#34;提交的描述信息\u0026#34; -a=\u0026#34;作者\u0026#34; 容器id 目标镜像名:[TAG] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 启动一个默认的tomcat [root@docker ~]# docker run -it -p 8080:8080 tomcat:9.0 Using CATALINA_BASE: /usr/local/tomcat Using CATALINA_HOME: /usr/local/tomcat Using CATALINA_TMPDIR: /usr/local/tomcat/temp Using JRE_HOME: /usr/local/openjdk-11 Using CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar Using CATALINA_OPTS: NOTE: Picked up JDK_JAVA_OPTIONS: --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name: Apache Tomcat/9.0.56 # 发现这个默认的tomcat 是没有webapps应用的 官方的镜像webapps目录下默认没有文件 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0a2f11347ef5 tomcat:9.0 \u0026#34;catalina.sh run\u0026#34; 11 minutes ago Up 10 minutes 0.0.0.0:8080-\u0026gt;8080/tcp, :::8080-\u0026gt;8080/tcp loving_nightingale [root@docker ~]# docker exec -it 0a2f11347ef5 /bin/bash root@0a2f11347ef5:/usr/local/tomcat# cd webapps root@0a2f11347ef5:/usr/local/tomcat/webapps# ls root@0a2f11347ef5:/usr/local/tomcat/webapps# # 将webapps.dist目录下的文件拷贝到webapps目录下 root@0a2f11347ef5:/usr/local/tomcat# cp -r webapps.dist/* webapps root@0a2f11347ef5:/usr/local/tomcat# cd webapps root@0a2f11347ef5:/usr/local/tomcat/webapps# ls ROOT docs examples host-manager manager # 将我们操作过的这个容器通过commit提交为一个新的镜像，我们以后就使用这个镜像即可 [root@docker ~]# docker commit -a=\u0026#34;satan\u0026#34; -m=\u0026#34;add webapps app\u0026#34; 0a2f11347ef5 tomcat2:2.0 sha256:6ae624cd277319840b93a7208edb4f32cfb56dc03fd3e40db8b11f2af1e414d4 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat2 2.0 6ae624cd2773 14 minutes ago 685MB nginx latest 605c77e624dd 12 months ago 141MB tomcat 9.0 b8e65a4d736d 13 months ago 680MB redis latest 7614ae9453d1 13 months ago 113MB centos latest 5d0da3dc9764 16 months ago 231MB portainer/portainer latest 580c0e4e98b0 22 months ago 79.1MB elasticsearch 7.6.2 f29a1ee41030 2 years ago 791MB 容器数据卷 什么是容器数据卷 回顾之前的不足\n我们的数据都在容器中，如果我们容器删除，数据就会丢失 mysql数据库中的数据，如果容器删掉了，重要数据无备份 因此，有了新的需求\n数据可以持久化 mysql数据可以存储在本地 解决方案\n容器之间有一个数据共享的技术，Docker容器中产生的数据，同步到本地 这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！\n","date":"2023-01-10T00:00:00Z","image":"https://zhengzel.github.io/p/docker%E5%85%A5%E9%97%A8/background_hucc033844cac59f8990265f7eb0b951ce_195342_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/docker%E5%85%A5%E9%97%A8/","title":"Docker入门"},{"content":" 命令行前加sudo，可以加权，普通用户可以执行一些root的操作，root用户则无需使用\n","date":"2023-01-10T00:00:00Z","image":"https://zhengzel.github.io/p/linux%E5%85%A5%E9%97%A8/background_hu17c71f546c30281edc50786cb15de534_125917_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/linux%E5%85%A5%E9%97%A8/","title":"Linux入门"},{"content":"本质 是面向对象设计原则的实际运用 优点 可以提高程序员的思维能力，编程能力和设计能力 使程序设计更加标准化，代码编制更加工程化，软件开发效率大大提高，缩短了项目的开发周期 使设计的代码可复用性高，可读性强，可靠性高，灵活性好，可维护性强 GoF23 创建型模式：单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式 结构型模式：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式 行为型模式：模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式,状态模式，策略模式，职责链模式，访问者模式 OOP七大原则 开闭原则：对扩展开放，对修改关闭（新增功能块不影响其他功能块的工作，能独立的工作） 里氏替换原则：继承必须确保父类所拥有的性质在子类中仍然成立(子类尽量不要重写父类的方法，要在原有的基础上扩展) 依赖倒置原则：要面向接口编程，不要面向实现编程 单一职责原则：控制类的粒度大小，将对象解耦，提高其内聚性(一个方法尽量做一件事情 ) 接口隔离原则：要为各个类建立它们需要的专用接口 迪米特法则：只和你的直接朋友交谈，不跟 “ 陌生人” 讲话 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 单例模式 饿汉式单例 可能会浪费空间 懒汉式单例 解决了饿汉式的弊端，在需要用的时候，再加载需要的对象 工厂模式 核心本质：实例化对象不使用new,用工厂方法替代\n简单工厂模式 工厂方法模式 抽象工厂模式 简单工厂模式(静态工厂模式) 对于增加的新的产品，需要覆盖已有代码\n！虽然某种程度上不符合设计原则，但实际使用最多\n工厂方法模式 在不修改已有类的前提下，通过增加新的工厂类实现扩展\n抽象工厂模式 围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂\n建造者模式 优点 产品的建造和表示分离，实现了解耦，使用建造者模式可以使客户端不必知道产品内部组成的细节 将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰 具体的建造者类之间是相互独立的，这有利于系统的扩展，增加新的具体建造者无需修改原有的代码，符合开闭原则 缺点 建造者模式创建的产品一般具有较多的共同点，如果产品差异性很大，就不适合使用建造者模式 如果产品的内部变化复杂，则需要定义很多具体建造者来实现这种变化，系统会变得很庞大 原型模式 实质是将创建的对象进行克隆，提高程序效率\n适配器模式 例子 \u0026mdash; 电脑 - 转接器 - 网线\n桥接模式 最佳实践 \u0026ndash; 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展\n静态代理 例子 \u0026mdash; 租房的人，中介，房东\n动态代理 动态代理的代理类是动态生成的，不是我们直接写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 ","date":"2022-12-30T00:00:00Z","image":"https://zhengzel.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/background_hue324fec1f8d8395b7b28e0e32e0dc587_86513_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/","title":"设计模式入门"},{"content":"概念 分布式协调服务 \u0026mdash; 实质是分布式锁 什么是分布式锁 ","date":"2022-12-23T00:00:00Z","image":"https://zhengzel.github.io/p/zookeeper%E5%88%9D%E6%8E%A2/background_hub1fdd9b6168bbde3eaa5087e4bf6af99_129657_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/zookeeper%E5%88%9D%E6%8E%A2/","title":"Zookeeper初探"},{"content":"解决方案 Spring Boot + Spring Cloud （特点：组件多 功能完备 Http通信） \u0026mdash; 成熟的微服务架构解决方案 Spring Boot + Dubbo + Zookeeper （特点：组件少 功能非完备 RPC框架通信） 常见问题 客户端如何访问这么多的服务？ \u0026mdash; API网关\n服务与服务之间如何通信？\n同步通信 ​\tHTTP（Apache Http Client）\n​\tRPC（Dubbo\u0026mdash;只支持Java Apache Thrift gPRC）\n异步通信\n​\t消息队列（Kafka RabbitMQ RocketMQ）\n这么多服务，如何管理？\n服务治理\n​\t服务注册与发现\n​\t基于客户端的服务注册与发现\n​\tZookeeper\n​\t基于服务端的服务注册与发现\n​\tEureka\n服务挂了，怎么办？（重试机制 服务熔断 服务降级 服务限流）\n最大的问题 \u0026mdash;\u0026gt; 网络是不可靠的\n","date":"2022-12-23T00:00:00Z","image":"https://zhengzel.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A2%E7%B4%A2/background_hub4d49487ea9e10ea596b27dab7564aa2_1096215_120x120_fill_box_smart1_3.png","permalink":"https://zhengzel.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A2%E7%B4%A2/","title":"微服务探索"},{"content":"了解阿里云用户权限操作 进入Accesskey管理 登录阿里云，点击工作台，进入后台\n点击头像下方的AccessKey管理，使用子用户\n用户组创建与权限分配 创建用户组\n添加短信服务权限\n用户创建 创建用户（注意勾选OpenAPI调用访问）添加到用户组中\nAccessKey ID\n开通阿里云短信服务 添加签名 进入短信服务控制台\n点击国内消息，即可添加签名\n添加签名 (无需添加【】符号，会自动添加)，注意场景说明，审核通过即可\n创建模板 模板内容可以在常用模板库中查找，场景说明注意事项同上 右侧可以预览效果，审核通过即可\n编写测试代码 帮助文档：HelpDos\n创建SpringBoot项目并导入依赖 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tea-openapi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dysmsapi20170525\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.23\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2022-12-14T00:00:00Z","image":"https://zhengzel.github.io/p/%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81%E6%9C%8D%E5%8A%A1/background_hu93a62d240f11e8aa3a3e3557db25aa68_54671_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81%E6%9C%8D%E5%8A%A1/","title":"短信发送服务"},{"content":"实体类 公共的字段，如id,createTime,updateTime,提取出来，放到一个公共的类上，其他的实体类继承 每个实体类都需要实现Serializable接口(序列化) URL路径 所有的接口必须根据该接口的版本，在 /api 后添加 /v1 或其他版本号。且根据该接口的功能在随后添加功能。（例：/api/v1/auth/login） 请求方式采用 Restful 风格，例：GET POST PUT DELETE，这四种请求方式必须与业务相契合。 数据库设计 主键 Id 的类型应设为 bigint，数据库字符集应设为 utf8_mb4 每张表必须含有创建时间与更新时间这两个关键字段 每个字段一定要写备注 当字段设为 not null 时，应为其设置默认值 Redis 在redisTemplete的基础上封装一个redisUtils加以利用 ","date":"2022-12-13T00:00:00Z","image":"https://zhengzel.github.io/p/java%E7%9C%9F%E5%AE%9E%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/background_hu467fe8a469c9dd15ae2f318aa21eec43_109857_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/java%E7%9C%9F%E5%AE%9E%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","title":"Java真实开发规范"},{"content":"概念 Filter : 过滤器，用来过滤网站的数据\n作用 处理中文乱码 登录验证 流程 ","date":"2022-12-13T00:00:00Z","image":"https://zhengzel.github.io/p/springboot%E5%B0%8F%E8%AE%B0/background_hu9099bbeb7de511b6e027296562b69dae_240565_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/springboot%E5%B0%8F%E8%AE%B0/","title":"SpringBoot小记"},{"content":"概念 Filter : 过滤器，用来过滤网站的数据\n作用 处理中文乱码 登录验证 流程 ","date":"2022-12-11T00:00:00Z","image":"https://zhengzel.github.io/p/filter%E8%BF%87%E6%BB%A4%E5%99%A8/background_hu72070b12d64f00df02a8337603afefd0_92687_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/filter%E8%BF%87%E6%BB%A4%E5%99%A8/","title":"Filter(过滤器)"},{"content":"使用Hugo新建站点 在任意位置新建一个文件夹，用于存放博客文件，执行\n1 hugo new site . 则会创建出如下文件：\n","date":"2022-12-04T00:00:00Z","image":"https://zhengzel.github.io/p/hugo-stack%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80/background_huaada557d81dfacc1dcb88c7c9b70ae20_166679_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhengzel.github.io/p/hugo-stack%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80/","title":"Hugo+Stack搭建个人博客(一)"}]